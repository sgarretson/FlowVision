# FlowVision Development Rules for GitHub Best Practices

## Core Development Principles

You are an expert development assistant for the FlowVision project. Always follow these rules to maintain clean, synchronized, and professional GitHub repository management.

## GitHub Workflow Requirements

### Branch Management
- **NEVER commit directly to main branch**
- **ALWAYS create feature branches** with enhanced naming: `type/epic-id-story-id-description`
  - Examples: `feature/epic-2-story-15-ai-response-caching`, `bugfix/sprint-5-auth-session-timeout`
- **ALWAYS verify branch protection** is enabled before making changes
- **ALWAYS keep feature branches small and focused** (single feature/fix per branch)
- **ALWAYS delete merged feature branches** both locally and remotely

### Enhanced Commit Standards
- **ALWAYS use enhanced commit format**: `type(scope): description [story: ID] [points: X] [learns: insight]`
  - Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
  - Examples: `feat(ai): implement response caching [story: SYS-15] [points: 5] [learns: 70% cost reduction with Redis]`
- **ALWAYS include learning annotations** for significant changes or discoveries
- **ALWAYS reference story ID** when working on sprint tasks
- **ALWAYS document story point impact** for estimation accuracy tracking
- **ALWAYS test locally before committing**
- **ALWAYS run `npm test` and ensure it passes**
- **ALWAYS clear build cache** (`rm -rf .next`) if encountering React/build errors

### Enhanced Pull Request Process
- **ALWAYS create PR for any code changes**
- **ALWAYS use enhanced PR template** with learning capture sections
- **ALWAYS include story context** (ID, points, epic, sprint)
- **ALWAYS document technical learnings** and process insights
- **ALWAYS assess story point accuracy** and variance factors
- **ALWAYS update relevant documentation** when making architectural changes
- **ALWAYS request review before merging**
- **ALWAYS ensure CI/CD checks pass before requesting review**
- **ALWAYS resolve merge conflicts locally, never in GitHub UI**
- **NEVER force push to shared branches**
- **NEVER bypass branch protection without explicit approval**

### Code Quality Gates
- **ALWAYS run linting**: `npm run lint` (fix issues before committing)
- **ALWAYS run tests**: `npm test` (must pass before pushing)
- **ALWAYS verify build**: `npm run build` (for production readiness)
- **ALWAYS check for TypeScript errors**: Address all `tsc` warnings
- **ALWAYS validate database schema changes** with `npx prisma validate`

## Pre-Commit Checklist

Before every commit, verify:
- [ ] Code changes are tested locally
- [ ] No console.log statements in production code
- [ ] No hardcoded values (use environment variables)
- [ ] All imports are properly typed
- [ ] No unused variables or imports
- [ ] Database queries use proper error handling
- [ ] API routes have proper authentication checks
- [ ] React components use proper key props in lists

## Sync Management

### Daily Sync Protocol
1. **Start of day**: `git pull origin main`
2. **Before creating branch**: Ensure main is up-to-date
3. **End of work**: Push feature branch and create PR
4. **Never leave uncommitted changes** in working directory

### Emergency Procedures
If you encounter:
- **React "Objects are not valid as React child"**: Clear build cache with `rm -rf .next`
- **Module not found errors**: Clear cache and restart dev server
- **GitHub sync issues**: Create new feature branch from latest main
- **CI/CD failures**: Fix issues locally, never bypass checks
- **Merge conflicts**: Resolve locally with `git rebase main`
- **TypeScript null/undefined errors**: Transform Prisma nulls to undefined using `?? undefined`
- **Stuck interactive rebase**: Remove `.git/*.swp` files and set `git config core.editor "cat"`
- **Merge conflict markers in files**: Manually resolve all `<<<<<<<`, `=======`, `>>>>>>>` markers

## Repository Hygiene

### File Management
- **ALWAYS add appropriate .gitignore entries** for build artifacts
- **NEVER commit**: `.next/`, `node_modules/`, `.env.local`, IDE files
- **ALWAYS commit**: Lock files (`package-lock.json`, `yarn.lock`)
- **ALWAYS use absolute paths** in tool configurations when possible

### Documentation Organization
- **ALWAYS categorize documentation** in appropriate `/docs/` subfolder
- **NEVER place documentation** in project root except README.md, CONTRIBUTING.md, LICENSE
- **ALWAYS update category README.md** when adding new documentation
- **ALWAYS use relative links** for cross-document references
- **MAXIMUM 10 files per folder** without creating subfolders
- **ALWAYS follow naming conventions**: UPPERCASE_DOCUMENT.md for main docs, README.md for indexes

### Documentation Standards
- **ALWAYS update README.md** for significant feature additions
- **ALWAYS document API changes** in relevant files
- **ALWAYS add JSDoc comments** for complex functions
- **ALWAYS update CHANGELOG.md** for releases
- **ALWAYS place documents** in correct category: architecture, development, security, project-management, design, quality-assurance, production, analysis-reports, user-guides, templates

### Naming Convention Standards
- **NEVER use subjective qualifiers**: enhanced, optimized, improved, advanced, better, new, custom, special
- **ALWAYS use functional descriptors**: service, manager, handler, engine, processor, validator, factory
- **ALWAYS use domain-driven naming**: `{domain}-{function}.ts` (e.g., `ai-service.ts`, `user-authentication.ts`)
- **ALWAYS name for what code does**, not how well it does it
- **ALWAYS use clear, descriptive names** that remain relevant as system evolves
- **ALWAYS follow patterns**: Class names should be `NounFunction` (e.g., `UserService`, `DataValidator`)
- **ALWAYS use consistent casing**: kebab-case for files, PascalCase for types/classes, camelCase for variables/functions

## Error Prevention Rules

### React/Next.js Specific
- **ALWAYS use TypeScript strict mode**
- **ALWAYS define interfaces** for component props and API responses
- **ALWAYS handle loading and error states** in components
- **ALWAYS use proper async/await patterns** in API routes
- **NEVER render objects directly** in JSX (use specific properties)

### Database/Prisma
- **ALWAYS use transactions** for multi-table operations
- **ALWAYS validate input** before database queries
- **ALWAYS handle Prisma errors** with try/catch blocks
- **ALWAYS test schema changes** with seed data
- **ALWAYS transform** database `null` to `undefined` for external APIs using `?? undefined`

### AI/LLM Integration
- **ALWAYS validate** AI service configuration before use (`isConfigured()`)
- **ALWAYS include** confidence scores for AI-generated content
- **ALWAYS provide** fallback when AI services are unavailable
- **ALWAYS sanitize** AI responses before database storage
- **ALWAYS track** AI usage and costs in audit logs
- **ALWAYS indicate** AI-generated content with clear attribution
- **NEVER expose** OpenAI API keys in client-side code
- **ALWAYS use null-safe operations** for optional AI fields (`|| []` fallbacks)
- **ALWAYS provide proper context** for AI recommendations (systems, processes, people)

### Security
- **ALWAYS validate user permissions** in API routes
- **ALWAYS sanitize user input** before database operations
- **ALWAYS use environment variables** for secrets
- **NEVER commit API keys or passwords**

## Tool Integration

### Required Commands
Before any PR:
```bash
# Clean build
rm -rf .next

# Run full validation
npm run lint
npm test
npm run build

# Database validation
npx prisma validate
npx prisma generate
```

### GitHub CLI Usage
- Use `gh pr create` for consistent PR creation
- Use `gh pr status` to check PR state
- Use `gh pr checks` to verify CI/CD status
- Use `gh issue list` to track open issues

## Sprint & Process Awareness

### Current Sprint Context
- **ALWAYS reference** current sprint goals when implementing features: docs/project-management/sprint-plans/
- **ALWAYS check** SYSTEMS_ENHANCEMENT_EXECUTION_PLAN.md for current sprint status
- **ALWAYS align** work with current epic objectives and business value
- **ALWAYS consider** sprint capacity and velocity when estimating work
- **ALWAYS update** story status when making related code changes

### Learning Integration Requirements
- **ALWAYS capture** performance insights in commit messages using [learns: ] annotation
- **ALWAYS document** architectural decisions with ADRs in docs/architecture/
- **ALWAYS update** relevant documentation when process changes
- **ALWAYS track** time estimates vs. actual implementation time for velocity improvement
- **ALWAYS follow** Continuous Learning Framework: docs/project-management/processes/CONTINUOUS_LEARNING_FRAMEWORK.md

### Memory Management
Remember these key project facts:
- Project uses Docker for development environment
- Prefer no icons/emojis in user-facing content
- Keep 'facebook-ad-campaign' and 'Google_PPC' folders local only
- Main branch requires PR workflow with reviews
- All major features need comprehensive testing
- Systems Enhancement is major release - use proper GitHub project management
- Always include addressedIssues in initiative queries to prevent undefined errors
- Use proper null checking for all optional array fields in frontend components
- Team capacity is ~60 story points per 2-week sprint with 10% buffer
- Sprint naming follows: Sprint X (dates) with clear goals and deliverables
- Expert profiles available in EXPERT_PROFILES_SYSTEM.md for consistent decision-making
- Background automation workflows defined in CURSOR_BACKGROUND_AUTOMATION.md
- Source code management framework: docs/development/SOURCE_CODE_MANAGEMENT_FRAMEWORK.md

## Conflict Resolution Best Practices

### Merge Conflict Prevention
- **ALWAYS rebase** feature branches regularly with main
- **KEEP branches** small and focused (single responsibility)
- **COMMUNICATE** with team before large refactoring
- **TEST locally** before pushing any merge resolution

### When Conflicts Occur
1. **STOP** and assess the scope of conflicts
2. **BACKUP** current work with `git stash` if needed
3. **RESOLVE** conflicts in order: simple to complex
4. **TEST thoroughly** after each resolution
5. **COMMIT** with descriptive merge commit message
6. **VERIFY** CI/CD passes before requesting reviews

### Common Conflict Patterns
- **Import statements**: Usually safe to combine both imports
- **Function implementations**: Choose the more complete version
- **Configuration files**: Merge security and functionality features
- **Type definitions**: Combine interfaces, avoid duplicates

## Systems Enhancement Project Rules

### Sprint Planning & Execution Framework
- **ALWAYS reference** SYSTEMS_ENHANCEMENT_EXECUTION_PLAN.md for current sprint details
- **ALWAYS update** completion status in the execution plan when stories are done
- **ALWAYS validate** story acceptance criteria before marking complete
- **ALWAYS conduct** sprint retrospectives and update velocity metrics
- **ALWAYS adjust** future sprint planning based on actual capacity

### Feature Development Protocol
- **ALWAYS use GitHub Projects** for milestone and task tracking
- **ALWAYS create detailed issues** before starting development
- **ALWAYS link commits to issues** using `#issue-number` in commit messages
- **ALWAYS update project status** when moving between development phases
- **ALWAYS coordinate with team** before modifying shared components
- **ALWAYS create feature branch** following pattern: `feature/sprint-X-story-Y-description`

### Database Schema Changes
- **ALWAYS create migration scripts** for schema changes
- **ALWAYS test migrations** with existing seed data
- **ALWAYS update TypeScript types** when schema changes
- **ALWAYS validate relationships** between new and existing entities
- **ALWAYS backup production data** before schema migrations

### API Design Standards
- **ALWAYS follow RESTful conventions** for new endpoints
- **ALWAYS include proper error responses** with status codes
- **ALWAYS validate request payloads** using Zod or similar
- **ALWAYS include response type definitions** in TypeScript
- **ALWAYS test API endpoints** with both valid and invalid data

### Sprint Progress Tracking
- **BEFORE starting** a story: Update status to "IN PROGRESS" in execution plan
- **DURING development**: Update GitHub issue with progress comments
- **WHEN blocked**: Document blockers in both GitHub issue and execution plan
- **UPON completion**: Mark story as âœ… in execution plan and close GitHub issue
- **AT sprint end**: Update velocity metrics and conduct retrospective

### Story Completion Validation
- **ALWAYS verify** all acceptance criteria are met before marking complete
- **ALWAYS run** full test suite before story completion
- **ALWAYS update** any affected documentation
- **ALWAYS demo** completed functionality to product owner
- **ALWAYS check** story points accuracy for future sprint planning

### Expert Consultation Framework
- **BEFORE major decisions**: Consult relevant expert profile guidance from EXPERT_PROFILES_SYSTEM.md
- **DURING implementation**: Follow expert quality gates and decision frameworks
- **AFTER completion**: Validate against expert quality criteria
- **FOR conflicts**: Use expert hierarchy and escalation paths defined in profiles
- **FOR architecture**: Technical Architect + AI Architect + Security Architect review required
- **FOR design**: UX Strategist + UI Designer + Accessibility Specialist validation needed
- **FOR business logic**: Product Manager + Business Analyst + Requirements Engineer approval

### Background Automation Framework
- **ALWAYS trigger** relevant background agents on file changes
- **ALWAYS validate** agent outputs against expert profiles
- **ALWAYS update** sprint progress automatically via agents
- **ALWAYS escalate** critical issues immediately through automation
- **ALWAYS maintain** automation logs for debugging and optimization
- **BEFORE commits**: Run code quality and security agents
- **DURING development**: Continuous testing and documentation agents active
- **AFTER merges**: Deployment and monitoring agents execute
- **ON schedule**: Performance and security scanning agents run

## Enforcement

If any of these rules are violated:
1. **STOP current work**
2. **FIX the violation** immediately
3. **DOCUMENT the fix** in commit message
4. **REVIEW process** to prevent recurrence

These rules are mandatory for maintaining professional, scalable, and reliable development practices.